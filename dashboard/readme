# **Documentação do Dashboard: Arquitetura BigQuery & Looker Studio**

- **Autor:** Arthur R. Neri
- **Data de Criação:** 11 de setembro de 2025
- **Versão:** 2.0 (Arquitetura em Nuvem)
- Link para Dashboard: https://lookerstudio.google.com/reporting/a98da5a8-e0b3-45cb-88c3-ccf14a495793

### **1. Visão Geral da Arquitetura**

Para superar os desafios de conexão de um banco de dados local com uma ferramenta de BI na nuvem, o projeto foi migrado para uma arquitetura 100% Google Cloud. Os dados brutos (CSVs) foram carregados no Google BigQuery, que serve como o Data Warehouse central. O Looker Studio se conecta diretamente ao BigQuery para consumir os dados e gerar as visualizações.

### **2. Configuração do Ambiente Google Cloud / BigQuery**

As seguintes etapas foram necessárias para preparar o ambiente:

1. **Criação do Projeto Google Cloud:** Um novo projeto foi criado com as seguintes especificações:
    - **Nome do Projeto:** `bike-store`
    - **ID do Projeto:** `bike-store-471719`
2. **Criação do Conjunto de Dados no BigQuery:** Dentro do projeto, um conjunto de dados foi criado para conter todas as tabelas.
    - **ID do Conjunto de Dados:** `bike_store`
3. **Ativação de APIs Essenciais:** Para permitir a comunicação entre o Looker Studio e o BigQuery, as seguintes APIs foram ativadas no projeto:
    - `BigQuery API`
    - `BigQuery Connection API`
    - `Cloud Resource Manager API`
4. **Vinculação da Conta de Faturamento:** O projeto foi vinculado a uma conta de faturamento ativa para permitir a execução de queries no BigQuery. O uso para este projeto se enquadra no nível gratuito do serviço.

### **3. Processo de Carga de Dados (Importação para o BigQuery)**

Os 9 datasets originais em formato CSV foram carregados diretamente na interface do BigQuery.

- **Método:** Para cada uma das 9 tabelas, o seguinte processo foi utilizado:
    1. Dentro do conjunto de dados `bike_store`, a opção **"CRIAR TABELA"** foi selecionada.
    2. **Origem:** A opção **"Upload"** foi usada para carregar o arquivo CSV do computador local.
    3. **Nome da Tabela:** O nome da tabela foi definido para corresponder ao arquivo (ex: `orders`, `products`).
    4. **Esquema (Schema):** A opção **"Detecção automática"** foi utilizada para que o BigQuery definisse os tipos de dados de cada coluna.
    5. **Cabeçalho:** Nas "Opções Avançadas", o campo **"Linhas de cabeçalho a serem ignoradas"** foi configurado como `1`.

### **4. Ponto Crítico: Dialeto SQL (Legacy vs. Standard)**

Durante a fase de testes, foi descoberto que o ambiente BigQuery do projeto, por padrão, estava operando com o dialeto **Legacy SQL**. Funções modernas do Standard SQL (como `FORMAT_NUMERIC`) não funcionaram. Embora a partir da análise 6, conseguirmos utilizar o modelo Standard 

- **Decisão:** Para garantir a consistência, foi decidido prosseguir utilizando a sintaxe **Legacy SQL no primeiro momento, porém alternamos para o modelo Standard a partir da análise 6 pois o Legacy apresentou bugs**. A sintaxe do Legacy SQL se diferencia principalmente na forma de referenciar as tabelas.
- **Sintaxe (Legacy SQL):** `[ID_do_Projeto:ID_do_Conjunto_de_Dados.Nome_da_Tabela]`
    - **Exemplo Prático:** `[bike-store-471719:bike_store.orders]`

### **5. Conexão e Configuração do Looker Studio**

A conexão final do dashboard foi estabelecida com as seguintes preferências:

- **Conector:** `BigQuery`.
- **Método de Consulta:** Todas as fontes de dados para gráficos e KPIs foram criadas usando a opção **"CONSULTA PERSONALIZADA"**, onde os scripts SQL (em dialeto Legacy) são inseridos.
- **Regra de Ouro da Formatação:** Para máxima flexibilidade e performance, foi estabelecido o seguinte padrão:
    1. A query SQL deve retornar os valores numéricos **brutos**, sem formatação de texto (sem `R$`, `%` ou vírgulas decimais).
    2. Toda a formatação visual (moeda, porcentagem, casas decimais) é aplicada diretamente no Looker Studio, na aba de **"CONFIGURAÇÃO"** da métrica ou na aba de **"ESTILO"** do gráfico.
- Exemplo de Query Padrão (Legacy SQL - Sem Formatação):

```sql
-- Template de query para Looker Studio
SELECT
  SUM(oi.quantity * oi.list_price * (1 - oi.discount)) AS Receita_Total
FROM
  [bike-store-471719:bike_store.orders] AS o
JOIN
  [bike-store-471719:bike_store.order_items] AS oi ON o.order_id = oi.order_id
WHERE o.order_status IN (3, 4);
```

# Documentação de queries para Looker

### **1. KPI - Receita Total**

- **Objetivo:** Calcular o valor total em dólar de todas as vendas enviadas ou concluídas.
- **Tipo de Visualização:** Cartão de pontuação.
- **Query para BigQuery (Legacy SQL):**

```sql
-- Retorna o valor bruto da receita
SELECT
  SUM(oi.quantity * oi.list_price * (1 - oi.discount)) AS Receita_Total
FROM
  [bike-store-471719:bike_store.orders] AS o
JOIN
  [bike-store-471719:bike_store.order_items] AS oi ON o.order_id = oi.order_id
WHERE o.order_status IN (3, 4);
```

### **2. KPI - Total de Pedidos**

- **Objetivo:** Contar o número total de vendas enviadas ou concluídas.
- **Tipo de Visualização:** Cartão de pontuação.
- **Query para BigQuery (Legacy SQL):**

```sql
-- Retorna o número total de pedidos válidos
SELECT
  COUNT(o.order_id) AS Total_Pedidos
FROM
  [bike-store-471719:bike_store.orders] AS o
WHERE o.order_status IN (3, 4);
```

### **3. KPI - Clientes Únicos**

- **Objetivo:** Contar quantos clientes distintos fizeram pelo menos uma compra válida.
- **Tipo de Visualização:** Cartão de pontuação.
- **Query para BigQuery (Legacy SQL):**

```sql
-- Retorna o número de clientes únicos com pedidos válidos
SELECT
  COUNT(DISTINCT o.customer_id) AS Clientes_Unicos
FROM
  [bike-store-471719:bike_store.orders] AS o
WHERE o.order_status IN (3, 4);
```

### **4. KPI - Ticket Médio**

- **Objetivo:** Calcular o valor médio de cada transação (Receita Total / Total de Pedidos).
- **Tipo de Visualização:** Cartão de pontuação.
- **Query para BigQuery (Legacy SQL):**

```sql
-- Análise 4: KPI - Ticket Médio (CORRIGIDO PARA LEGACY SQL)
SELECT
  -- Usamos CASE WHEN para evitar divisão por zero
  CASE
    WHEN COUNT(o.order_id) > 0
    THEN SUM(oi.quantity * oi.list_price * (1 - oi.discount)) / COUNT(o.order_id)
    ELSE 0
  END AS Ticket_Medio
FROM
  [bike-store-471719:bike_store.orders] AS o
JOIN
  [bike-store-471719:bike_store.order_items] AS oi ON o.order_id = oi.order_id
WHERE o.order_status IN (3, 4);
```

### **5. KPI - Receita Média por Cliente**

- **Objetivo:** Calcular o valor médio que cada cliente único gerou em receita (Receita Total / Clientes Únicos).
- **Tipo de Visualização:** Cartão de pontuação.
- **Query para BigQuery (Legacy SQL):**

```sql
-- Análise 5: KPI - Receita Média por Cliente (CORRIGIDO PARA LEGACY SQL)
SELECT
  -- Usamos CASE WHEN para evitar divisão por zero
  CASE
    WHEN COUNT(DISTINCT o.customer_id) > 0
    THEN SUM(oi.quantity * oi.list_price * (1 - oi.discount)) / COUNT(DISTINCT o.customer_id)
    ELSE 0
  END AS Receita_Media_Por_Cliente
FROM
  [bike-store-471719:bike_store.orders] AS o
JOIN
  [bike-store-471719:bike_store.order_items] AS oi ON o.order_id = oi.order_id
WHERE o.order_status IN (3, 4);
```

### **6. Receita por Marca**

- **Objetivo:** Visualizar a contribuição de receita de cada marca, identificando as mais importantes financeiramente para o negócio.
- **Tipo de Visualização:** **Gráfico de Barras Verticais**.
- Query para BigQuery (Standard SQL): Aqui precisamos voltar para o modo Standard pois o Legacy mode não estava funcionando conforme o esperado

```sql
#standardSQL
-- Versão final e definitiva em Standard SQL
SELECT
  b.brand_name,
  SUM(oi.quantity * oi.list_price * (1 - oi.discount)) AS receita_total
FROM
  `bike-store-471719.bike_store.brands` AS b
JOIN
  `bike-store-471719.bike_store.products` AS p ON b.brand_id = p.brand_id
JOIN
  `bike-store-471719.bike_store.order_items` AS oi ON p.product_id = oi.product_id
JOIN
  `bike-store-471719.bike_store.orders` AS o ON oi.order_id = o.order_id
WHERE o.order_status IN (3, 4)
GROUP BY
  b.brand_name
ORDER BY
  receita_total DESC;
```

### 7. Receita por Loja

- **Objetivo:** Visualizar o desempenho financeiro de cada loja para entender a distribuição geográfica da receita e identificar a loja de maior faturamento.
- **Tipo de Visualização:** Gráfico de Barras
- Query para BigQuery (Standard SQL):

```sql
#standardSQL
-- Retorna a receita bruta total para cada loja, ordenada da maior para a menor
SELECT
  s.store_name,
  SUM(oi.quantity * oi.list_price * (1 - oi.discount)) AS receita_total
FROM
  `bike-store-471719.bike_store.stores` AS s
JOIN
  `bike-store-471719.bike_store.orders` AS o ON s.store_id = o.store_id
JOIN
  `bike-store-471719.bike_store.order_items` AS oi ON o.order_id = oi.order_id
WHERE o.order_status IN (3, 4)
GROUP BY
  s.store_name
ORDER BY
  receita_total DESC;
```

### **8. Evolução da Receita por Ano**

- **Objetivo:** Visualizar a tendência de crescimento da receita da empresa ano a ano.
- **Tipo de Visualização:** **Gráfico de Linhas**
- **Query para BigQuery (Standard SQL):**

```sql
#standardSQL
-- Retorna a receita bruta total para cada ano
SELECT
  EXTRACT(YEAR FROM o.order_date) AS ano,
  SUM(oi.quantity * oi.list_price * (1 - oi.discount)) AS receita_total
FROM
  `bike-store-471719.bike_store.orders` AS o
JOIN
  `bike-store-471719.bike_store.order_items` AS oi ON o.order_id = oi.order_id
WHERE o.order_status IN (3, 4)
GROUP BY
  ano
ORDER BY
  ano;
```

### 9. Top Produtos Trek em NY

- **Objetivo:** Identificar os produtos específicos da marca Trek que geram mais receita na loja de maior desempenho (Baldwin Bikes).
- **Tipo de Visualização:** **Gráfico de Barras Horizontais**
- **Query para BigQuery (Standard SQL):**

```sql
#standardSQL
-- Retorna os 10 produtos Trek mais vendidos por receita na loja Baldwin Bikes
SELECT
  p.product_name,
  SUM(oi.quantity * oi.list_price * (1 - oi.discount)) AS receita_total
FROM
  `bike-store-471719.bike_store.stores` AS s
JOIN
  `bike-store-471719.bike_store.orders` AS o ON s.store_id = o.store_id
JOIN
  `bike-store-471719.bike_store.order_items` AS oi ON o.order_id = oi.order_id
JOIN
  `bike-store-471719.bike_store.products` AS p ON oi.product_id = p.product_id
JOIN
  `bike-store-471719.bike_store.brands` AS b ON p.brand_id = b.brand_id
WHERE
  o.order_status IN (3, 4)
  AND s.store_name = 'Baldwin Bikes' -- Filtro pela loja
  AND b.brand_name = 'Trek'          -- Filtro pela marca
GROUP BY
  p.product_name
ORDER BY
  receita_total DESC
LIMIT 10; -- Pegamos os 10 principais
```

### **10. Análise de Descontos por Produto**

- **Objetivo:** Identificar os produtos que recebem a maior média de desconto, para analisar a estratégia de precificação e o possível impacto na margem de lucro.
- **Tipo de Visualização:** **Tabela**. Uma tabela é a melhor visualização aqui porque queremos ver várias informações lado a lado para cada produto (desconto, unidades vendidas, receita) e poder ordená-las de diferentes maneiras.
- **Query para BigQuery (Standard SQL):**

```sql
#standardSQL
-- Retorna os 15 produtos com a maior média de desconto aplicado
SELECT
  p.product_name,
  AVG(oi.discount) AS media_desconto,
  SUM(oi.quantity) AS unidades_vendidas,
  SUM(oi.quantity * oi.list_price * (1 - oi.discount)) AS receita_total
FROM
  `bike-store-471719.bike_store.products` AS p
JOIN
  `bike-store-471719.bike_store.order_items` AS oi ON p.product_id = oi.product_id
JOIN
  `bike-store-471719.bike_store.orders` AS o ON oi.order_id = o.order_id
WHERE
  o.order_status IN (3, 4)
  AND oi.discount > 0 -- Focamos apenas nos itens que tiveram algum desconto
GROUP BY
  p.product_name
ORDER BY
  media_desconto DESC
LIMIT 15;
```

### **11. Receita Mensal ao Longo do Tempo**

- **Objetivo:** Visualizar a tendência da receita mês a mês ao longo de todo o período, para identificar padrões de sazonalidade (meses de alta e baixa) e a trajetória de crescimento.
- **Tipo de Visualização:** **Gráfico de Séries Temporais (Time series chart)**.
- **Query para BigQuery (Standard SQL):**

```sql
#standardSQL
-- Retorna a receita total para cada mês/ano
SELECT
  -- Esta função agrupa todos os dias de um mês no primeiro dia daquele mês.
  -- Ex: '2017-08-25' se torna '2017-08-01'. Isso cria um campo de data perfeito para o gráfico.
  DATE_TRUNC(o.order_date, MONTH) AS mes_ano,
  SUM(oi.quantity * oi.list_price * (1 - oi.discount)) AS receita_mensal
FROM
  `bike-store-471719.bike_store.orders` AS o
JOIN
  `bike-store-471719.bike_store.order_items` AS oi ON o.order_id = oi.order_id
WHERE o.order_status IN (3, 4)
GROUP BY
  mes_ano
ORDER BY
  mes_ano;
```

### 12. Frequência de Compra dos Clientes

- **Objetivo:** Entender a distribuição da base de clientes de acordo com o número de pedidos que eles fizeram. Isso nos ajuda a visualizar a proporção de clientes novos vs. clientes leais.
- **Tipo de Visualização:** **Gráfico de Barras Verticais**. Ideal para mostrar a contagem de clientes para cada "faixa" de frequência (clientes com 1 pedido, 2 pedidos, etc.).
- **Query para BigQuery (Standard SQL):**

```sql
#standardSQL
-- Retorna a contagem de clientes para cada frequência de compra
WITH FrequenciaClientes AS (
  -- Primeiro, contamos quantos pedidos cada cliente fez
  SELECT
    customer_id,
    COUNT(order_id) AS numero_de_pedidos
  FROM
    `bike-store-471719.bike_store.orders`
  WHERE
    order_status IN (3, 4)
  GROUP BY
    customer_id
)
-- Agora, contamos quantos clientes existem para cada número de pedidos
SELECT
  numero_de_pedidos,
  COUNT(customer_id) AS numero_de_clientes
FROM
  FrequenciaClientes
GROUP BY
  numero_de_pedidos
ORDER BY
  numero_de_pedidos;
```

### **13. Recalculando os Clientes VIP (A Versão da Verdade)**

Para solidificar essa descoberta e termos a lista correta dos nossos melhores clientes (mesmo que eles tenham comprado poucas vezes), vamos refazer a análise de "Clientes Mais Valiosos" com a nossa lógica correta no BigQuery.

- **Objetivo:** Gerar a lista definitiva dos 10 clientes mais valiosos com base em vendas reais (`status 3 ou 4`).
- **Tipo de Visualização:** **Tabela**.
- **Query para BigQuery (Standard SQL):**

```sql
#standardSQL
-- Retorna os 10 clientes mais valiosos com base em vendas reais
SELECT
  c.first_name,
  c.last_name,
  c.city,
  c.state,
  COUNT(o.order_id) AS total_pedidos_validos,
  SUM(oi.quantity * oi.list_price * (1 - oi.discount)) AS valor_total_gasto
FROM
  `bike-store-471719.bike_store.customers` AS c
JOIN
  `bike-store-471719.bike_store.orders` AS o ON c.customer_id = o.customer_id
JOIN
  `bike-store-471719.bike_store.order_items` AS oi ON o.order_id = oi.order_id
WHERE o.order_status IN (3, 4)
GROUP BY
  c.customer_id, c.first_name, c.last_name, c.city, c.state
ORDER BY
  valor_total_gasto DESC
LIMIT 10;
```

### **14. Comparativo Mensal de Vendas (Trek vs. Electra) em 2017 vs. 2018**

- **Objetivo:** Comparar o desempenho de vendas mensais das duas marcas principais (Trek e Electra) durante o ano de pico (2017) e o ano do colapso (2018). Isso nos permitirá ver se a queda foi generalizada ou se afetou uma marca mais do que a outra.
- **Tipo de Visualização:** **Gráfico de Combinação (Combo chart)** ou **Gráfico de Linhas com múltiplas séries**. Esta é a melhor forma de comparar diferentes categorias (as marcas) ao longo do tempo.
- **Query para BigQuery (Standard SQL):**

```sql
#standardSQL
-- Retorna a receita mensal para as marcas Trek e Electra nos anos de 2017 e 2018
SELECT
  DATE_TRUNC(o.order_date, MONTH) AS mes_ano,
  b.brand_name,
  SUM(oi.quantity * oi.list_price * (1 - oi.discount)) AS receita_mensal
FROM
  `bike-store-471719.bike_store.orders` AS o
JOIN
  `bike-store-471719.bike_store.order_items` AS oi ON o.order_id = oi.order_id
JOIN
  `bike-store-471719.bike_store.products` AS p ON oi.product_id = p.product_id
JOIN
  `bike-store-471719.bike_store.brands` AS b ON p.brand_id = b.brand_id
WHERE
  o.order_status IN (3, 4)
  AND EXTRACT(YEAR FROM o.order_date) IN (2017, 2018) -- Filtro para os dois anos chave
  AND b.brand_name IN ('Trek', 'Electra')             -- Filtro para as duas marcas chave
GROUP BY
  mes_ano,
  brand_name
ORDER BY
  mes_ano,
  brand_name;
```

### LINK PARA O DASHBOARD: https://lookerstudio.google.com/reporting/a98da5a8-e0b3-45cb-88c3-ccf14a495793

### **Conclusão Final Sobre a Crise de 2018**

A crise de 2018 não foi uma queda geral de mercado ou um problema com todas as lojas. Foi um evento muito específico: por algum motivo, a empresa **parou de vender produtos da Trek**. As hipóteses para isso seriam:

- Uma ruptura no fornecimento com a Trek.
- A perda da licença de revendedor da marca.
- Uma decisão estratégica desastrosa de parar de vender a marca mais lucrativa.
- Um problema de dados específico que parou de registrar as vendas da Trek.

